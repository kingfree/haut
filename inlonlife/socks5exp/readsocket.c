#include <kern/debug.h>#include <sys/errno.h>#include <sys/kpi_mbuf.h>#include <sys/kpi_socket.h>#include <net/kpi_protocol.h>#include <net/ethernet.h>#include <sys/param.h>#include <sys/filio.h>#define ULTIMATE_ANSWER 0x00000042/* Forward declarations */errno_t set_nonblocking(socket_t so, int value);static void my_sock_callback(socket_t so, void* cookie, int waitf);/* This function opens a connection and sets it up to waitfor data.  When data is received, the network stack willcall the callback function my_sock_callback(). */errno_t open_socket_and_start_listener(void){    socket_t so;    errno_t err;    int protocol = 0; // usually the right choice    struct sockaddr to;    uint32_t cookie = ULTIMATE_ANSWER; // Normally, we would    // point to a private    // data structure here.    if ((err = sock_socket(PF_INET, SOCK_STREAM, protocol, (sock_upcall)&my_sock_callback, (void *)cookie, &so))) {        return err;    }    /* Set the socket to non-blocking mode */    set_nonblocking(so, 1);    /* ... Fill in sockaddr value here ... */    err = sock_connect(so, &to, MSG_DONTWAIT);    if (err == EINPROGRESS) return 0; // it worked.    return err;}/* This function is called when data is available on the socket.It reads data from the socket. */static void my_sock_callback(socket_t so, void* cookie, int waitf){    errno_t err;    size_t len = sizeof(value);    mbuf_t data;    int value;    /* The socket should have some data available now. */    if (cookie == (void *)ULTIMATE_ANSWER) {        // This socket's cookie matches the desired magic value,        // so read data from the socket here.        err = sock_receivembuf(so, NULL, &data, MSG_WAITALL, &len);        if (err == EWOULDBLOCK) {            // The kernel hasn't seen enough data yet.            return;        } else if (err || len < sizeof(value)) {            /* This example does no error recovery.  Your code should. */            panic("Something is very wrong.  Maybe the other end closed the            connection....\n");        }    }    // Copy the data from the mbuf chain into local storage.    err = mbuf_copydata(data, 0, sizeof(value), &value); // Copy 4 bytes at start    // Call a function with the value received.    dont_panic(htonl(value));    // We no longer need this socket, so close it.    sock_close(so);}/* This is a short example of how to use the sock_ioctl()function on a socket within the kernel.  This is theKPI equivalent of the ioctl() system call. */errno_t set_nonblocking(socket_t so, int value){    errno_t err;    int val = value; // taking the address of parameters is bad    if (value != 0 && value != 1) return EINVAL;    err = sock_ioctl(so, FIONBIO, &val);    return err;}