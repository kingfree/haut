\section{概要设计}

% \subsection{函数调用关系}

\begin{sidewaysfigure}
\centering
\newcommand{\defun}[2]{{\it #2}\\ {#1}}
% \newcommand{\defun}[2]{{#1}}

% \smartdiagram[constellation diagram]{
% \defun{编码文件}{huffman encode file},
% \smartdiagram[sequence diagram]{
%   \defun{获取频率}{get symfreq},
%   \defun{新叶结点}{new leaf node},
%   \defun{建立符号编码表}{build symcode},
%   },
% \defun{计算编码}{calc code},
% \defun{写出编码表}{write code table},
% \defun{编码}{do file encode},
% \defun{销毁编码表}{free encoder},
% \defun{销毁树}{free tree}
% }
\begin{tikzpicture}[align=center]
% \draw[help lines] (0,0) grid (20,11);

\node (A) at (27em,10) [ellipse,draw] {\defun{压缩文件}{huffman\_encode\_file}};
  \node (B1) at (7em,8) [draw] {\defun{获取频率}{get\_symfreq}};
  \draw[<-] (node cs:name=B1,anchor=north) |- (7em,9) -| (node cs:name=A,anchor=south);
    \node (C11) at (0em,6) [draw] {\defun{排序比较函数}{sfcmp}};
    \draw[<-] (node cs:name=C11,anchor=north) |- (7em,7);
    \node (C12) at (7em,6) [draw] {\defun{新叶结点}{new\_leaf\_node}};
    \draw[<-] (node cs:name=C12,anchor=north) |- (node cs:name=B1,anchor=south);
    \node (C13) at (15em,6) [draw] {\defun{建立符号编码表}{build\_symcode}};
    \draw[<-] (node cs:name=C13,anchor=north) |- (7em,7);
      \node (D) at (15em,4) [draw] {\defun{创建编码}{new\_code}};
      \draw[<-] (node cs:name=D,anchor=north) |- (node cs:name=C13,anchor=south);
  \node (B2) at (25em,8) [draw] {\defun{计算编码}{calc\_code}};
  \draw[<-] (node cs:name=B2,anchor=north) |- (25em,9) -| (node cs:name=A,anchor=south);
    \node (C21) at (22em,6) [draw] {\defun{新结点}{new\_node}};
    \draw[<-] (node cs:name=C21,anchor=north) |- (22em,7) -| (node cs:name=B2,anchor=south);
    \node (C22) at (28em,6) [draw] {\defun{初始化频率表}{init\_freq}};
    \draw[<-] (node cs:name=C22,anchor=north) |- (28em,7) -| (node cs:name=B2,anchor=south);
  \node (B3) at (35em,8) [draw] {\defun{写出编码表}{write\_code\_table}};
  \draw[<-] (node cs:name=B3,anchor=north) |- (35em,9) -| (node cs:name=A,anchor=south);
    \node (C31) at (33.4em,6) [circle,draw] {\emph{fwrite}};
    \draw[<-] (node cs:name=C31,anchor=north) |- (35em,7) -| (node cs:name=B3,anchor=south);
    \node (C32) at (36.6em,6) [circle,draw] {\emph{htonl}};
    \draw[<-] (node cs:name=C32,anchor=north) |- (35em,7) -| (node cs:name=B3,anchor=south);
  \node (B4) at (44em,8) [draw] {\defun{进行文件编码}{do\_file\_encode}};
  \draw[<-] (node cs:name=B4,anchor=north) |- (44em,9) -| (node cs:name=A,anchor=south);
  \node (B5) at (44em,6) [draw] {\defun{销毁编码表}{free\_encoder}};
  \draw[<-] (node cs:name=B5,anchor=east) |- (50em,6) |- (35em,9) -| (node cs:name=A,anchor=south);
    \node (C5) at (44em,4) [draw] {\defun{销毁编码}{free\_code}};
    \draw[<-] (node cs:name=C5,anchor=north) |- (node cs:name=B5,anchor=south);
  \node (B6) at (40em,2) [draw] {\defun{销毁树}{free\_tree}};
  \draw[<-] (node cs:name=B6,anchor=east) |- (50em,2) |- (35em,9) -| (node cs:name=A,anchor=south);

\node (G) at (32em,0) [ellipse,draw] {\defun{解压缩文件}{huffman\_decode\_file}};
  \node (F) at (22em,2) [draw] {\defun{读入编码表}{read\_code\_table}};
  \draw[->] (node cs:name=G,anchor=north) |- (35em,1) -| (node cs:name=F,anchor=south);
    \node (E1) at (33.4em,4) [circle,draw] {\emph{fread}};
    \draw[->] (node cs:name=F,anchor=north) |- (35em,3) -| (node cs:name=E1,anchor=south);
    \node (E2) at (36.6em,4) [circle,draw] {\emph{ntohl}};
    \draw[->] (node cs:name=F,anchor=north) |- (35em,3) -| (node cs:name=E2,anchor=south);

  \draw[<-] (node cs:name=C21,anchor=south) |- (22em,3) -| (node cs:name=F,anchor=north);
  \draw[<-] (node cs:name=C12,anchor=south) |- (22em,3) -| (node cs:name=F,anchor=north);
\draw[<-] (node cs:name=B6,anchor=south) |- (35em,1) -| (node cs:name=G,anchor=north);

\end{tikzpicture}

% \begin{tikzpicture}
% \node {\defun{编码文件}{huffman encode file}}
%   child {node {\defun{计算编码}{calc code}}}
%   child {node {\defun{获取频率}{get symfreq}}
%     child {node {\defun{新叶结点}{new leaf node}}}
%     child {node {\defun{建立符号编码表}{build symcode}}}
%   }
%   child {node {\defun{写出编码表}{write code table}}}
%   child {node {\defun{编码}{do file encode}}}
%   child {node {\defun{销毁编码表}{free encoder}}}
%   child {node {\defun{销毁树}{free tree}}};
% \end{tikzpicture}

\caption{\label{funcall}两个接口对主要函数之间的调用关系}
\end{sidewaysfigure}


\subsection{程序运行逻辑}

我们首先考虑程序运行的主要逻辑。当键入程序名运行程序时，应该给出帮助信息，告诉用户应该怎样使用本程序。假定运行程序名为 {\sf huff}。

考虑到要压缩文件并输出，至少我们需要两个参数即\verb|<输入文件>|和\verb|<输出文件>|。所以，要压缩一个 {\sf 文件1} 到 {\sf 文件2} ，键入命令 \verb|huff 文件1 文件2| 即可。

对于解压文件，可以直接加一个参数 \verb|-u|。比如把 {\sf 文件2} 解压成 {\sf 文件3}，应当键入命令 \verb|huff 文件2 文件3 -u|。

我们还可以提供如下选项：
\begin{quote}
\begin{description}[topsep=0pt,partopsep=0pt,itemsep=0pt,parsep=0pt]
\item[-i]   输入文件
\item[-o]   输出文件
\item[-u]   解压缩
\item[-z]   压缩（默认）
\item[-h]   显示本帮助
\item[-v]   显示版本信息
\end{description}
\end{quote}
使用 \verb|getopt()| 函数即可处理这些参数。

默认情况下，对于正常完成的操作，不应该输出提示信息，直接结束即可。对于异常情况，则输出错误信息并结束程序，返回错误码。

\newcommand{\des}[2]{\makebox[2em][s]{\bf #1}\quad #2}
\newcommand{\function}[5]{\CTEXnoindent
    \underline{\makebox[\textwidth][l]{\it{#1}}}\\
    {\tt {{#3}} {\bfseries #1}(#2);}\\
    \des{返回}{#4}\\
    \des{描述}{#5}\par
\CTEXindent}

\subsection{接口定义}

第~\pageref{funcall}~页的横排大图 \ref{funcall} 展示了这两个对外接口对主要函数之间的调用关系。

\function{huffman\_encode\_file}
{FILE *in, FILE *out}
{int}{成功返回 0}
{读入文件 {\tt in}，编码之后输出到 {\tt out} 中。首先获取输入文件中符号出现频率，依此调用 Huffman 算法生成编码表。再次扫描文件，使用之前生成的编码表来编码，每读入一个位就进行对照编码表进行编码，满一个字节就写出，最后不满补 0。}

% \subsection{文件操作}
% \begin{verbatim}
% /* 对文件编码 */
% int do_file_encode(FILE *in, FILE *out, symcode *sc)
% \end{verbatim}

\function{huffman\_decode\_file}
{FILE *in, FILE *out}
{int}{成功返回 0}
{读入文件 {\tt in}，解码之后输出到 {\tt out} 中。首先读入编码表，构建对应的 Huffman 树。接着按位读入后面的数据，不断查询 Huffman 树知道叶结点，输出解码结果，不断重复到文件直到末尾。}

\subsection{位操作}

\begin{figure}[htp]
\centering
\umlDiagram[sizeX=4.4cm, sizeY=3.4cm]{
  \umlClass{code}
    {\umlAttribute[type=\texttt{unsigned long}]{\emph{len}}}
    {\umlAttribute[type=\texttt{unsigned char *}]{\emph{bits}}}
}
\caption{\label{code}码字数据类型}
\end{figure}

如图 \ref{code}，定义数据类型 \verb|code| 用来存储位数据，其 \verb|len| 表示编码位长， \verb|bits| 是指向存储编码值得指针，一个 \verb|bits[]| 表示八位编码。

\function{bit\_len\_byte}
{unsigned long len}
{unsigned long}{字节长度}
{把位的长度转换成字节的长度，不足 8 位则进位。}

\function{get\_bit}
{unsigned char *bits, unsigned long i}
{unsigned char}{0 或 1}
{获取 $bits$ 的第 $i$ 位二进制位。}

\function{reversc\_bits}
{unsigned char *bits, unsigned long len}
{void}{无}
{把长度为 $len$ 的 $bits$ 依二进制位反转。}

\function{new\_code}
{const node *leaf}
{code *}{指向生成的编码结构体的指针}
{从叶结点 $leaf$ 沿 Huffman 树回溯到根结点，逆序生成该叶结点对应符号的 Huffman 编码序列。}

\function{free\_code}
{code *p}
{void}{无}
{销毁编码 $p$ 。}

\subsection{符号表}

定义符号表类型：
\begin{itemize}[topsep=0pt,partopsep=0pt,itemsep=0pt,parsep=0pt]
\item 符号频率表 \verb|symfreq[]| 是一个长为 256 的结点数组类型，主要用来存储符号出现频率以构建 Huffman 树；
\item 符号编码表 \verb|symcode[]| 是一个长为 256 的编码数组类型，用来存储符号对应的编码。
\end{itemize}

\function{init\_freq}
{symfreq *sf}
{void}{无}
{初始化符号频率表 $sf$。}

\function{get\_symfreq}
{symfreq *sf, FILE *in}
{unsigned int}{文件 {\tt in} 中的符号总数}
{读入文件 {\tt in} 中所有符号，统计符号总数，并把每个符号出现次数保存到符号频率表 $sf$ 中。}

\function{write\_code\_table}
{FILE *out, symcode *sc, uint32\_t syms}
{int}{成功返回 0}
{向文件 {\tt out} 中写出符号编码表 $sc$。写出的具体格式如下：
\begin{enumerate}[topsep=0pt,partopsep=0pt,itemsep=0pt,parsep=0pt]
  \item （4 字节） 编码大小 $n$，即 $sc$ 的大小，以网络字节顺序写出
  \item （4 字节） 待编码字节数 $syms$，即文件大小，以网络字节顺序写出
  \item 符号的具体编码 $code[1..n]$ ，每个 $code[i]$ 的编码格式为：
  \begin{enumerate}[topsep=0pt,partopsep=0pt,itemsep=0pt,parsep=0pt]
    \item （1 字节） 符号，即原字符本身
    \item （1 字节） 位长，即下面的编码位长度，单位是位
    \item 具体编码位数据。如果编码不是 8 的倍数的话，最后一字节会有用以补 0 的多余位
  \end{enumerate}
\end{enumerate}
}

\function{read\_code\_table}
{FILE *in, unsigned int *pdb}
{node *}{从文件中构建的 Huffman 树}
{从文件 {\tt in} 中读入符号编码表。以网络字节顺序，首先读入符号总数 $count$，然后读入待解码的符号总数 $pdb$。接着依据规则读入符号编码表，依此构建 Huffman 树，并把文件偏移设置到符号编码表末尾。}

\function{free\_encoder}
{symcode *sc}
{void}{无}
{销毁符号编码表 $sc$。}

\subsection{Huffman 树}

\begin{figure}[htp]
\centering
\umlDiagram[sizeX=4.8cm, sizeY=6.4cm]{
  \umlClass{node}{\umlAttribute[type=\texttt{bool}]{\emph{leaf}}
    \umlAttribute[type=\texttt{unsigned long}]{\emph{count}}
    \umlAttribute[type=\texttt{unsigned char *}]{\emph{bits}}
  }{\umlAttribute[visibility=-,type=\texttt{node *}]{\emph{zero}}
    \umlAttribute[visibility=-,type=\texttt{node *}]{\emph{one}}
    \umlAttribute[visibility=+,type=\texttt{unsigned char}]{\emph{symbol}}
  }
}
\caption{\label{node}结点数据类型}
\end{figure}

如图 \ref{node}，定义数据类型 \verb|node| 用来存储 Huffman 树的结点。其 \verb|leaf| 标识是否为叶结点，如果是叶结点，联合体用 \verb|symbol| 存储该结点表示的符号；如果不是，则使用含有 \verb|zero| 和 \verb|one| 指针域的结构体来存储左右子树的地址。
 \verb|count| 存储该结点的频率（频数），指针 \verb|parent| 指向该结点的父亲。

\function{new\_leaf\_node}
{unsigned char symbol}
{node *}{生成的结点地址}
{生成一个叶结点，其保存了符号 $symbol$。}

\function{new\_node}
{unsigned long count, node *zero, node *one}
{node *}{生成的结点地址}
{生成一个普通结点，其保存了频数 $count$，左右孩子分别是 $zero$ 和 $one$。}

\function{sfcmp}
{const void *p1, const void *p2}
{int}{正数表示 $p1 > p2$，零表示相等，负数表示 $p2<p1$}
{对符号频率表进行排序的比较函数，用于 {\tt qsort()}。规则是低频率在前，高频率在后，频率为 0 即频率为空的在末尾。}

\function{calc\_code}
{symfreq *sf}
{symcode *}{已编码的数组指针}
{从符号频率表 $sf$ 建立 Huffman 树的主算法。首先获取符号数 $n$，然后对频率进行增序排序。接着构建 Huffman 树，每次取出并删除 $sf$ 最前面两个元素，合并成新的结点并加入 $sf$，调用 {\tt qsort()} 进行增序排序以维护有序性，如此进行 $n-1$ 次即可构建成功。最后调用 {\tt build\_symcode()} 生成符号编码表并返回。}

\function{build\_symcode}
{node *root, symcode *sc}
{void}{无}
{以 $root$ 为根遍历以构建好的 Huffman 树，建立符号编码表 $sc$。}

\function{free\_tree}
{node *root}
{void}{无}
{从根结点 $root$ 开始递归销毁这棵 Huffman 树。}
