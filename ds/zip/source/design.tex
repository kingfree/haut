\section{概要设计}

\subsection{程序运行逻辑}

我们首先考虑程序运行的主要逻辑。当键入程序名运行程序时，应该给出帮助信息，告诉用户应该怎样使用本程序。假定运行程序名为 {\sf huff}。

考虑到要压缩文件并输出，至少我们需要两个参数即\verb|<输入文件>|和\verb|<输出文件>|。所以，要压缩一个 {\sf 文件1} 到 {\sf 文件2} ，键入命令 \verb|huff 文件1 文件2| 即可。

对于解压文件，可以直接加一个参数 \verb|-u|。比如把 {\sf 文件2} 解压成 {\sf 文件3}，应当键入命令 \verb|huff 文件2 文件3 -u|。

我们还可以提供如下选项：
\begin{quote}
\begin{description}
\item[-i]   输入文件
\item[-o]   输出文件
\item[-u]   解压缩
\item[-z]   压缩（默认）
\item[-h]   显示本帮助
\item[-v]   显示版本信息
\end{description}
\end{quote}
使用 \verb|getopt()| 函数即可处理这些参数。

默认情况下，对于正常完成的操作，不应该输出提示信息，直接结束即可。对于异常情况，则输出错误信息并结束程序，返回错误码。

\newcommand{\des}[2]{\makebox[2em][s]{\bf #1}\quad #2}
\newcommand{\function}[5]{\CTEXnoindent
    \underline{\makebox[\textwidth][l]{\it{#1}}}\\
    {\tt {\bfseries\color{violet}{#3}} #1(#2);}\\
    \des{返回}{#4}\\
    \des{描述}{#5}\par
\CTEXindent}

\subsection{接口定义}

\function{huffman\_encode\_file}
{FILE *in, FILE *out}
{int}{成功返回 0}
{读入文件 {\tt in}，编码之后输出到 {\tt out} 中。}

\function{huffman\_decode\_file}
{FILE *in, FILE *out}
{int}{成功返回 0}
{读入文件 {\tt in}，解码之后输出到 {\tt out} 中。}

\subsection{位操作}

\begin{center}
\umlClass{\makebox[3.5cm]{code}}{
  len: unsigned long\\
  bits: unsigned char *\\
}
\end{center}

定义数据类型 \verb|code| 用来存储位数据，其 \verb|len| 表示编码位长， \verb|bits| 是指向存储编码值得指针，一个 \verb|bits[]| 表示八位编码。

\function{bit\_len\_byte}
{unsigned long len}
{unsigned long}{字节长度}
{把位的长度转换成字节的长度，不足 8 位则进位。}

\function{get\_bit}
{unsigned char *bits, unsigned long i}
{unsigned char}{0 或 1}
{获取 $bits$ 的第 $i$ 位二进制位。}

\function{reversc\_bits}
{unsigned char *bits, unsigned long len}
{void}{无}
{把长度为 $len$ 的 $bits$ 依二进制位反转。}

\begin{verbatim}
/* 对叶节点生成编码 */
code *new_code(const node *leaf)
\end{verbatim}

\function{free\_code}
{code *p}
{void}{无}
{销毁编码 $p$ 。}

\subsection{符号表}

\function{free\_encoder}
{symcode *sc}
{void}{无}
{销毁符号编码表 $sc$。}

\begin{verbatim}
#define MAX_SYMBOLS 256
/* 符号频率表 */
typedef node *symfreq[MAX_SYMBOLS];
/* 符号编码表 */
typedef code *symcode[MAX_SYMBOLS];

void init_freq(symfreq *sf)

unsigned int get_symfreq(symfreq *sf, FILE *in)

/* 排序比较函数，低频率在前，空在末尾 */
int sfcmp(const void *p1, const void *p2)

/* 遍历子树建立符号编码表 */
void build_symcode(node *root, symcode *sf)

/* 写出编码表。格式如下：
 * * 4 字节编码大小 n
 * * 4 字节已编码字节数
 * * 编码 [1..n] ，每个编码 [i] 的格式为：
 *   * 1 字节符号，1 字节位长，编码字节（以 bit2byte 编码）
 *   * 如果编码不是 8 的倍数的话，最后一字节可能会有多余位
 */
int write_code_table(FILE *out, symcode *sc, uint32_t syms)
\end{verbatim}

\subsection{Huffman 树}

\begin{center}
\umlClass{node}{
  leaf: bool\\
  count: unsigned long\\
  parent: node *\\
  \hline
  \umlState{}{
    \umlNote{
      zero: node *\\
      one: node *
    }\\
    \umlNote{symbol: unsigned char}
  }\\
}
\end{center}

定义数据类型 \verb|node| 用来存储 Huffman 树的结点。其 \verb|leaf| 标识是否为叶结点，如果是叶结点，联合体用 \verb|symbol| 存储该结点表示的符号；如果不是，则使用含有 \verb|zero| 和 \verb|one| 指针域的结构体来存储左右子树的地址。
 \verb|count| 存储该结点的频率（频数），指针 \verb|parent| 指向该结点的父亲。

\function{new\_leaf\_node}
{unsigned char symbol}
{node *}{生成的结点地址}
{生成一个叶结点，其保存了符号 $symbol$。}

\function{new\_node}
{unsigned long count, node *zero, node *one}
{node *}{生成的结点地址}
{生成一个普通结点，其保存了频数 $count$，左右孩子分别是 $zero$ 和 $one$。}

\begin{verbatim}

/* 返回编码数组 */
symcode *calc_code(symfreq *sf)

\end{verbatim}

\function{free\_huffman\_tree}
{node *root}
{void}{无}
{从根结点 $root$ 开始递归销毁这棵 Huffman 树。}

\subsection{文件操作}

\begin{verbatim}
/* 读入编码表，返回构建的 Huffman 树 */
node *read_code_table(FILE *in, unsigned int *pdb)

/* 对文件编码 */
int do_file_encode(FILE *in, FILE *out, symcode *sc)

\end{verbatim}
