\section{概要设计}

实际上，C 作为系统编程语言，久经考验，使用好的方法便可以写出有良好表现和维护性的代码。按传统的过程式编程方法，对于一个较大型的项目来说，有点难以驾驭。

为了程序维护和修改方便，以及程序通用性，我采用了面向对象的编程方法，参考了面向对象和设计模式的相关书籍资料\footnote{主要是《设计模式解析》\cite{dpatt} \cite{dpatt_c}。}。
对于 C 语言来说，实现面向对象有点麻烦\footnote{学习《系统程序员成长计划》\cite{sys_grow} 中介绍的经验。}，不过基本上还是模块化编程的思想\footnote{参考《模块化 C：怎样编写可重用可维护的 C 语言代码》\cite{modc}。}。

\subsection{类的划分}

\begin{figure}[htp]
  \pictext\small
\begin{tikzpicture}
\umlemptyclass{UI}
\umlemptyclass[x=5, y=2]{SList}
\umlemptyclass[x=3, y=2]{List}
\umlemptyclass[x=-6, y=1]{Paper}
\umlemptyclass[x=-3, y=0]{Problem}
\umlemptyclass[x=-4, y=-3]{Score}
\umlemptyclass[x=2, y=-4]{User}
\umlaggreg[geometry=-|-]{List}{SList}
\umlcompo[geometry=|-]{Paper}{Problem}
\umlcompo[geometry=|-|]{Score}{Problem}
\umlcompo[geometry=-|]{Score}{Paper}
\umlaggreg[geometry=|-]{Score}{User}
\umldep[geometry=-|]{UI}{User}
\umldep[geometry=|-]{UI}{Paper}
\umldep[geometry=|-]{UI}{Problem}
\umldep[geometry=|-]{UI}{Score}
\umldep[geometry=-|]{UI}{List}
% \umluniassoc[geometry=|-,mult=0..*]{Paper}{List}
% \umluniassoc[geometry=|-|,mult=0..*]{Problem}{List}
% \umluniassoc[geometry=--,mult=0..*]{Score}{List}
\end{tikzpicture}
  \caption{\label{classes}各个类之间的关系}
\end{figure}

通过研究程序中出现的对象，我们可以抽象出若干个类。图~\ref{classes}~展示了各个类之间的关系。

首先，我决定使用 UI 类来控制所有与用户交互有关的操作，所有屏幕可显示字符串都存放在 UI 类中，便于修改和移植。

最重要的类是 Problem 类，提供题目存取和相关操作。Problem 类聚合可以生成试卷，即 Paper 类，用来存取试卷信息。学生和教师共用 User 类来存取，其中学生的成绩使用 Score 类存取。Score 类由 Paper 类和 User 类聚合而成，并且依赖于 Problem 类。

由于没有数据库，我设计一个 List 类来实现对文件的读取、写入和增、删、改、查操作。通过 UI 类将 List 类与其他类连接起来操作（这里也是本程序设计的不佳之处）。List 类是对单链表 SList 类的一个封装。

\subsection{List 类}

\newcommand\method[2]{{#1}:~{\it #2}}
\newcommand\vart[2]{{#1}:~{\it #2}}
\newcommand\argu[2]{{\sf #2}:~{\it #1}}
\newcommand\comt[1]{\hfill\quad{\tt //#1}}
\newcommand\comtn[1]{\\\comt{#1}}

List 类（图~\ref{list}）存储一个链表，记录链表元素个数和元素中最大编号。除了初始化和销毁操作之外，提供从文件中读取、向文件中写入功能。对于链表本身，提供插入、删除、查找和遍历、查找遍历功能，通过传入回调函数来实现具体功能。

\begin{figure}[htp]
  \pictext\small
\begin{tikzpicture}
\umlclass{List}{
-- \argu{SList *}{slist} \comt{单链表头指针}\\
+ \argu{int}{max\_id} \comt{链表中元素最大编号}\\
+ \argu{int}{count} \comt{链表中元素个数}
}{
+ \method{list\_new()}{List *} \comt{创建链表}\\
+ \method{list\_free(\argu{List *}{list})}{void} \comt{销毁链表}\\
+ \method{read\_file\_to\_list(\argu{char *}{filename}, \argu{List *}{list}, \argu{size\_t}{size})}{int} \comt{读取文件到链表}\\
-- \method{list\_restore(\argu{List *}{list})}{void} \comt{排序整理链表}\\
\# \method{file\_data\_count(\argu{FILE *}{file}, \argu{size\_t}{size})}{int} \comt{获取文件大小}\\
+ \method{write\_list\_to\_file(\argu{char *}{filename}, \argu{List *}{list}, \argu{size\_t}{size})}{int} \comt{写出链表到文件}\\
+ \method{list\_insert(\argu{List *}{list}, \argu{void *}{p})}{int} \comt{插入到链表}\\
+ \method{list\_remove(\argu{List *}{list}, \argu{回调函数}{find}, \argu{void *}{data})}{void *} \comt{从列表删除}\\
+ \method{list\_find(\argu{List *}{list}, \argu{回调函数}{find}, \argu{void *}{data})}{void *} \comt{在列表中查找}\\
+ \method{list\_each\_call(\argu{List *}{list}, \argu{回调函数}{call}, \argu{void *}{data})}{void *} \comt{遍历链表}\\
+ \method{list\_find\_each\_call(\argu{List *}{list}, \argu{回调}{find}, \argu{void *}{data}, \argu{回调}{call}, \argu{void *}{userdata})}{void *} \comtn{遍历链表中符合条件的元素}\\
}
\end{tikzpicture}
  \caption{\label{list}List 类}
\end{figure}

List 类实际上是对单链表 SList 类的一个封装，同时提供了文件操作，在程序中实际上是作为数据库类存在的。

\subsection{SList 类}

SList 类是 GNU Libltdl 库的组成部分之一，经过了长时间的考验，是非常健壮的。尊重 LGPL 协议，我未对其代码做任何改动。本来我是想改动 SList 类来实现现在 List 类的功能的，但是我还是决定尊重版权，并且提高代码重用性。

\begin{figure}[htp]
  \pictext\small
\begin{tikzpicture}
\umlclass{SList}{
-- \argu{SList *}{next} \comt{指向下一元素地址的指针}\\
+ \argu{const void *}{userdata} \comt{指向数据域指针}\\
}{
+ \method{slist\_concat(\argu{SList *}{head}, \argu{SList *}{tail})}{SList *} \comt{链接两个单链表}\\
+ \method{slist\_cons(\argu{SList *}{item}, \argu{SList *}{slist})}{SList *} \comt{插入链表元素}\\
+ \method{slist\_delete(\argu{SList *}{slist}, \argu{回调函数}{delete\_fct})}{SList *} \comt{销毁链表}\\
+ \method{slist\_remove(\argu{SList **}{phead}, \argu{回调函数}{find}, \argu{void *}{matchdata})}{SList *} \comt{删除指定元素}\\
+ \method{slist\_reverse(\argu{SList *}{slist})}{SList *} \comt{反转链表}\\
-- \method{slist\_sort\_merge(\argu{SList *}{left}, \argu{SList *}{right}, \argu{比较函数}{compare}, \argu{void *}{userdata})}{SList *}\\
+ \method{slist\_sort(\argu{SList *}{slist}, \argu{比较函数}{compare}, \argu{void *}{userdata})}{SList *} \comt{快速排序}\\
+ \method{slist\_tail(\argu{SList *}{slist})}{SList *} \comt{取下一个元素}\\
+ \method{slist\_nth(\argu{SList *}{slist}, \argu{size\_t}{n})}{SList *} \comt{取第$n$个元素}\\
+ \method{slist\_find(\argu{SList *}{slist}, \argu{回调函数}{find}, \argu{void *}{matchdata})}{void *} \comt{查找指定元素}\\
+ \method{slist\_length(\argu{SList *}{slist})}{size\_t} \comt{取链表长度}\\
+ \method{slist\_foreach(\argu{SList *}{slist}, \argu{回调函数}{find}, \argu{void *}{userdata})}{void *} \comt{遍历每个元素}\\
+ \method{slist\_box(\argu{const void *}{userdata})}{SList *} \comt{封装数据}\\
+ \method{slist\_unbox(\argu{SList *}{item})}{void *} \comt{拆包数据}\\
}
\end{tikzpicture}
  \caption{\label{slist}SList 类}
\end{figure}

图~\ref{slist}~描述了 SList 类。每个 SList 对象都是一个链表元素，包含指向下一元素地址的指针和本结点元素的数据指针。

SList 类提供了链表操作的通用方法，包括附加、连接、销毁、删除、查找、遍历操作，还可以对其进行排序（使用快速排序）、反转，一般的取长度和取指定元素方法也必不可少。

\subsection{Problem 类}

\begin{figure}[htp]
  \pictext\small
\begin{tikzpicture}
\umlclass{Problem}{
+ \argu{int}{id} \comt{题目编号}\\
+ \argu{char[]}{des} \comt{题目描述}\\
+ \argu{char[4][]}{opt} \comt{选项}\\
+ \argu{char}{ans} \comt{答案}\\
+ \argu{short}{dif} \comt{难度系数}\\
+ \argu{short}{tag} \comt{知识点标签}\\
+ \argu{short}{chapter} \comt{章}\\
+ \argu{short}{section} \comt{节}\\
}{
+ \method{problem\_new()}{Problem *} \comt{创建题目并初始化}\\
+ \method{problem\_read\_file(\argu{List *}{list})}{int} \comt{读取题目数据库}\\
+ \method{problem\_write\_file(\argu{List *}{list})}{int} \comt{写出题目数据库}\\
}
\end{tikzpicture}
  \caption{\label{problem}Problem 类}
\end{figure}

图~\ref{problem}~所示的 Problem 类，有着题目的数据域。为了简便起见，采用四个选项的单选形式。

题目可以通过访问数据域直接操作，所以其本身的方法并不是很多，都托管给 UI 类了。

\subsection{Paper 类}



\subsection{User 类}



\subsection{Score 类}



\subsection{公共回调函数}
\label{sec_callback}

\begin{figure}[htp]
  \pictext\small
  % \input{uml/callback}
  \caption{\label{callback}回调函数接口}
\end{figure}



\subsection{UI 类}


